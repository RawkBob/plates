<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Introduction on Plates</title>
    <link>https://platesphp.com/</link>
    <description>Recent content in Introduction on Plates</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://platesphp.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Asset</title>
      <link>https://platesphp.com/extensions/asset/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/extensions/asset/</guid>
      <description>The asset extension can be used to quickly create &amp;ldquo;cache busted&amp;rdquo; asset URLs in your templates. This is particularly helpful for aggressively cached files that can potentially change in the future, such as CSS files, JavaScript files and images. It works by appending the timestamp of the file&amp;rsquo;s last update to its URL. For example, /css/all.css becomes /css/all.1373577602.css. As long as the file does not change, the timestamp remains the same and caching occurs.</description>
    </item>
    
    <item>
      <title>Community</title>
      <link>https://platesphp.com/extensions/community/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/extensions/community/</guid>
      <description>This is a list of all the known community extensions for the Plates library. Please feel free to submit a Pull Request to add your extension to this list.
 Laravel Provider Attributes Rendering - Transforms arrays into html tag attributes. Includer - Include your assets in an expert way. Tapestry - A blog aware, Plates based static site generator.  </description>
    </item>
    
    <item>
      <title>Extensions</title>
      <link>https://platesphp.com/engine/extensions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/engine/extensions/</guid>
      <description>Creating extensions couldn&amp;rsquo;t be easier, and can really make Plates sing for your specific project. Start by creating a class that implements \League\Plates\Extension\ExtensionInterface. Next, register your template functions within a register() method.
Simple extensions example use League\Plates\Engine; use League\Plates\Extension\ExtensionInterface; class ChangeCase implements ExtensionInterface { public function register(Engine $engine) { $engine-&amp;gt;registerFunction(&amp;#39;uppercase&amp;#39;, [$this, &amp;#39;uppercaseString&amp;#39;]); $engine-&amp;gt;registerFunction(&amp;#39;lowercase&amp;#39;, [$this, &amp;#39;lowercaseString&amp;#39;]); } public function uppercaseString($var) { return strtoupper($var); } public function lowercaseString($var) { return strtolower($var); } } To use this extension in your template, simply call your new functions:</description>
    </item>
    
    <item>
      <title>File Extensions</title>
      <link>https://platesphp.com/engine/file-extensions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/engine/file-extensions/</guid>
      <description>Plates does not enforce a specific template file extension. By default it assumes .php. This file extension is automatically appended to your template names when rendered. You are welcome to change the default extension using one of the following methods.
Constructor method // Create new engine and set the default file extension to &amp;#34;.tpl&amp;#34; $template = new League\Plates\Engine(&amp;#39;/path/to/templates&amp;#39;, &amp;#39;tpl&amp;#39;); Setter method // Sets the default file extension to &amp;#34;.tpl&amp;#34; after engine instantiation $template-&amp;gt;setFileExtension(&amp;#39;tpl&amp;#39;); Manually assign If you prefer to manually set the file extension, simply set the default file extension to null.</description>
    </item>
    
    <item>
      <title>Folders</title>
      <link>https://platesphp.com/engine/folders/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/engine/folders/</guid>
      <description>Folders make it really easy to organize and access your templates. Folders allow you to group your templates under different namespaces, each of which having their own file system path.
Creating folders To create folders, use the addFolder() method:
// Create new Plates instance $templates = new League\Plates\Engine(); // Add folders $templates-&amp;gt;addFolder(&amp;#39;admin&amp;#39;, &amp;#39;/path/to/admin/templates&amp;#39;); $templates-&amp;gt;addFolder(&amp;#39;emails&amp;#39;, &amp;#39;/path/to/email/templates&amp;#39;); Using folders To use the folders you created within your project simply append the folder name with two colons before the template name.</description>
    </item>
    
    <item>
      <title>Functions</title>
      <link>https://platesphp.com/engine/functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/engine/functions/</guid>
      <description>While extensions are awesome for adding additional reusable functionality to Plates, sometimes it&amp;rsquo;s easier to just create a one-off function for a specific use case. Plates makes this easy to do.
Registering functions // Create new Plates engine $templates = new \League\Plates\Engine(&amp;#39;/path/to/templates&amp;#39;); // Register a one-off function $templates-&amp;gt;registerFunction(&amp;#39;uppercase&amp;#39;, function ($string) { return strtoupper($string); }); To use this function in a template, simply call it like any other function:
&amp;lt;h1&amp;gt;Hello &amp;lt;?=$this-&amp;gt;e($this-&amp;gt;uppercase($name))&amp;lt;/h1&amp;gt; It can also be used in a batch compatible function:</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>https://platesphp.com/engine/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/engine/overview/</guid>
      <description>Plates uses a central object called the Engine, which is used to store the environment configuration, functions and extensions. It helps decouple your templates from the file system and other dependencies. For example, if you want to change the folder where your templates are stored, you can do so by simply changing the path in one location.
Basic usage // Create new Plates engine $templates = new League\Plates\Engine(&amp;#39;/path/to/templates&amp;#39;); // Add any additional folders $templates-&amp;gt;addFolder(&amp;#39;emails&amp;#39;, &amp;#39;/path/to/emails&amp;#39;); // Load any additional extensions $templates-&amp;gt;loadExtension(new League\Plates\Extension\Asset(&amp;#39;/path/to/public&amp;#39;)); // Create a new template $template = $templates-&amp;gt;make(&amp;#39;emails::welcome&amp;#39;); Dependency Injection Plates is designed to be easily passed around your application and easily injected in your controllers or other application objects.</description>
    </item>
    
    <item>
      <title>Installation</title>
      <link>https://platesphp.com/getting-started/installation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/getting-started/installation/</guid>
      <description>Using Composer Plates is available on Packagist and can be installed using Composer. This can be done by running the following command or by updating your composer.json file.
composer require league/plates Be sure to also include your Composer autoload file in your project:
require &amp;#39;vendor/autoload.php&amp;#39;; Downloading .zip file This project is also available for download as a .zip file on GitHub. Visit the releases page, select the version you want, and click the &amp;ldquo;Source code (zip)&amp;rdquo; download button.</description>
    </item>
    
    <item>
      <title>Simple Example</title>
      <link>https://platesphp.com/getting-started/simple-example/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/getting-started/simple-example/</guid>
      <description>Here is a simple example of how to use Plates. We will assume the following directory stucture:
`-- path `-- to `-- templates |-- template.php |-- profile.php Within your controller // Create new Plates instance $templates = new League\Plates\Engine(&amp;#39;/path/to/templates&amp;#39;); // Render a template echo $templates-&amp;gt;render(&amp;#39;profile&amp;#39;, [&amp;#39;name&amp;#39; =&amp;gt; &amp;#39;Jonathan&amp;#39;]); The page template &amp;lt;?php $this-&amp;gt;layout(&amp;#39;template&amp;#39;, [&amp;#39;title&amp;#39; =&amp;gt; &amp;#39;User Profile&amp;#39;]) ?&amp;gt;&amp;lt;h1&amp;gt;User Profile&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;Hello, &amp;lt;?=$this-&amp;gt;e($name)?&amp;gt;&amp;lt;/p&amp;gt; The layout template &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;&amp;lt;?=$this-&amp;gt;e($title)?&amp;gt;&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;?=$this-&amp;gt;section(&amp;#39;content&amp;#39;)?&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; </description>
    </item>
    
    <item>
      <title>Data</title>
      <link>https://platesphp.com/templates/data/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/templates/data/</guid>
      <description>It&amp;rsquo;s very common to share application data (variables) with a template. Data can be whatever you want: strings, arrays, objects, etc. Plates allows you set both template specific data as well as shared template data.
Assign data Assigning data is done from within your application code, such as a controller. There are a number of ways to assign the data, depending on how you structure your objects.
// Create new Plates instance $templates = new League\Plates\Engine(&amp;#39;/path/to/templates&amp;#39;); // Assign via the engine&amp;#39;s render method echo $templates-&amp;gt;render(&amp;#39;profile&amp;#39;, [&amp;#39;name&amp;#39; =&amp;gt; &amp;#39;Jonathan&amp;#39;]); // Assign via the engine&amp;#39;s make method $template = $templates-&amp;gt;make(&amp;#39;profile&amp;#39;, [&amp;#39;name&amp;#39; =&amp;gt; &amp;#39;Jonathan&amp;#39;]); // Assign directly to a template object $template = $templates-&amp;gt;make(&amp;#39;profile&amp;#39;); $template-&amp;gt;data([&amp;#39;name&amp;#39; =&amp;gt; &amp;#39;Jonathan&amp;#39;]); Accessing data Template data is available as locally scoped variables at the time of rendering.</description>
    </item>
    
    <item>
      <title>Escaping</title>
      <link>https://platesphp.com/templates/escaping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/templates/escaping/</guid>
      <description>Escaping is a form of data filtering which sanitizes unsafe, user supplied input prior to outputting it as HTML. Plates provides two shortcuts to the htmlspecialchars() function.
Escaping example &amp;lt;h1&amp;gt;Hello, &amp;lt;?=$this-&amp;gt;escape($name)?&amp;gt;&amp;lt;/h1&amp;gt; &amp;lt;!-- Using the alternative, shorthand function --&amp;gt; &amp;lt;h1&amp;gt;Hello, &amp;lt;?=$this-&amp;gt;e($name)?&amp;gt;&amp;lt;/h1&amp;gt; Batch function calls The escape functions also support batch function calls, which allow you to apply multiple functions, including native PHP functions, to a variable at one time.
&amp;lt;p&amp;gt;Welcome &amp;lt;?=$this-&amp;gt;e($name, &amp;#39;strip_tags|strtoupper&amp;#39;)?</description>
    </item>
    
    <item>
      <title>Functions</title>
      <link>https://platesphp.com/templates/functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/templates/functions/</guid>
      <description>Template functions in Plates are accessed using the $this pseudo-variable.
&amp;lt;p&amp;gt;Hello, &amp;lt;?=$this-&amp;gt;escape($name)?&amp;gt;&amp;lt;/p&amp;gt; Custom fuctions In addition to the functions included with Plates, it&amp;rsquo;s also possible to add one-off functions, or even groups of functions, known as extensions.
Batch function calls Sometimes you need to apply more than function to a variable in your templates. This can become somewhat illegible. The batch() function helps by allowing you to apply multiple functions, including native PHP functions, to a variable at one time.</description>
    </item>
    
    <item>
      <title>Inheritance</title>
      <link>https://platesphp.com/templates/inheritance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/templates/inheritance/</guid>
      <description>By combining layouts and sections, Plates allows you to &amp;ldquo;build up&amp;rdquo; your pages using predefined sections. This is best understand using an example:
Inheritance example The following example illustrates a pretty standard website. Start by creating a site template, which includes your header and footer as well as any predefined content sections. Notice how Plates makes it possible to even set default section content, in the event that a page doesn&amp;rsquo;t define it.</description>
    </item>
    
    <item>
      <title>Layouts</title>
      <link>https://platesphp.com/templates/layouts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/templates/layouts/</guid>
      <description>The layout() function allows you to define a layout template that a template will implement. It&amp;rsquo;s like having separate header and footer templates in one file.
Define a layout The layout() function can be called anywhere in a template, since the layout template is actually rendered second. Typically it&amp;rsquo;s placed at the top of the file.
&amp;lt;?php $this-&amp;gt;layout(&amp;#39;template&amp;#39;) ?&amp;gt;&amp;lt;h1&amp;gt;User Profile&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;Hello, &amp;lt;?=$this-&amp;gt;e($name)?&amp;gt;&amp;lt;/p&amp;gt; This function also works with folders:
&amp;lt;?php $this-&amp;gt;layout(&amp;#39;shared::template&amp;#39;) ?</description>
    </item>
    
    <item>
      <title>Nesting</title>
      <link>https://platesphp.com/templates/nesting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/templates/nesting/</guid>
      <description>Including another template into the current template is done using the insert() function:
&amp;lt;?php $this-&amp;gt;insert(&amp;#39;partials/header&amp;#39;) ?&amp;gt;&amp;lt;p&amp;gt;Your content.&amp;lt;/p&amp;gt; &amp;lt;?php $this-&amp;gt;insert(&amp;#39;partials/footer&amp;#39;) ?&amp;gt; The insert() function also works with folders:
&amp;lt;?php $this-&amp;gt;insert(&amp;#39;partials::header&amp;#39;) ?&amp;gt;Alternative syntax The insert() function automatically outputs the rendered template. If you prefer to manually output the response, use the fetch() function instead:
&amp;lt;?=$this-&amp;gt;fetch(&amp;#39;partials/header&amp;#39;)?&amp;gt;Assign data To assign data (variables) to a nested template, pass them as an array to the insert() or fetch() functions.</description>
    </item>
    
    <item>
      <title>Overview</title>
      <link>https://platesphp.com/templates/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/templates/overview/</guid>
      <description>Plates templates are very simple PHP objects. Generally you&amp;rsquo;ll want to create these using the two factory methods, make() and render(), in the engine. For example:
// Create new Plates instance $templates = new League\Plates\Engine(&amp;#39;/path/to/templates&amp;#39;); // Render a template in a subdirectory echo $templates-&amp;gt;render(&amp;#39;partials/header&amp;#39;); // Render a template echo $templates-&amp;gt;render(&amp;#39;profile&amp;#39;, [&amp;#39;name&amp;#39; =&amp;gt; &amp;#39;Jonathan&amp;#39;]); For more information about how Plates is designed to be easily added to your application, see the section on dependency injection.</description>
    </item>
    
    <item>
      <title>Sections</title>
      <link>https://platesphp.com/templates/sections/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/templates/sections/</guid>
      <description>The start() and stop functions allow you to build sections (or blocks) of content within your template, and instead of them being rendered directly, they are saved for use elsewhere. For example, in your layout template.
Creating sections You define the name of the section with the start() function. To end a section call the stop() function.
&amp;lt;?php $this-&amp;gt;start(&amp;#39;welcome&amp;#39;) ?&amp;gt;&amp;lt;h1&amp;gt;Welcome!&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;Hello &amp;lt;?=$this-&amp;gt;e($name)?&amp;gt;&amp;lt;/p&amp;gt; &amp;lt;?php $this-&amp;gt;stop() ?&amp;gt; Stacking section content By default, when you render a section its content will overwrite any existing content for that section.</description>
    </item>
    
    <item>
      <title>Syntax</title>
      <link>https://platesphp.com/templates/syntax/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/templates/syntax/</guid>
      <description>While the actual syntax you use in your templates is entirely your choice (it&amp;rsquo;s just PHP after all), we suggest the following syntax guidelines to help keep templates clean and legible.
Guidelines  Always use HTML with inline PHP. Never use blocks of PHP. Always escape potentially dangerous variables prior to outputting using the built-in escape functions. More on escaping here. Always use the short echo syntax (&amp;lt;?=) when outputting variables.</description>
    </item>
    
    <item>
      <title>URI</title>
      <link>https://platesphp.com/extensions/uri/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://platesphp.com/extensions/uri/</guid>
      <description>The URI extension is designed to make URI checks within templates easier. The most common use is marking the current page in a menu as &amp;ldquo;selected&amp;rdquo;. It only has one function, uri(), but can do a number of helpful tasks depending on the parameters passed to it.
Installing the URI extension The URI extension comes packaged with Plates but is not enabled by default, as it requires an extra parameter passed to it at instantiation.</description>
    </item>
    
  </channel>
</rss>
